#ifndef ACCEL_INFO_H
#define ACCEL_INFO_H
#ifdef __cplusplus
extern "C" {
#endif

struct accel_info_struct {
	int device_id; /* ID of the uio device  */
	int phys_base_addr;  /* passed in to accel_register */
	int addr_range;
	int virt_base_addr; /* this cannot be computed at compile time, and must be generated by a call to accel_open */
	int wait_flag; /* for checking if the accelerator is DONE */
	unsigned int done_reg_offset;
	unsigned int done_reg_mask;
	char *ip_type; /* axis_accelerator_adapter or generic_axi_lite or other */
};
typedef struct accel_info_struct accel_info_t;

/* accel_register creates the uio devices in sysfs */
void accel_register(void *info);
void accel_unregister(void *info);

/* accel_open opens the uio device and mmaps its base address to set the virtual_base_addr */
int accel_open(void *info);

/* accel_open closes the uio device and munmaps it */
void accel_close(void *info);

/* accel_wait waits for the accel to be done */
void accel_wait(void *info);

/* accel_set_wait_flag sets the wait flag for the accel */
void accel_set_wait_flag(void *info);

/* Check if adapter has space. Call before initiating transfer when necessary */
int accel_adapter_has_space(void *info, unsigned int offset);

/* accel_get_reg_info passes back the offsets related to the named register 
 * input 1 = void * pointer to the accel_info struct
 * input 2 = char * representing the register name
 * output 1 = offset of the register for reading/writing data 
 * output 2 = offset of an optional status register to check before writing data
 * output 3 = value of the status register that indicates the main register is ready for write 
 * output 4 = offset of an optional status register to check before reading data
 * output 5 = value of the status register that indicates the main register is ready for read
 */
void accel_get_reg_info(void *, char *, int *, int *, int *, int *, int *);

/* accel_get_start_seq passes back an int array representing the command sequence to use for starting the accelerator
 * input 1 = number of input scalars
 * input 2 = number of input arrays
 * input 3 = number of output scalars
 * input 4 = number of output arrays
 * input 5 = run mode - 0 for single execution and 1 for continous run
 * output 1 = int array representing the command sequence
 * output 2 = number of elements in the array of output 1
 */ 
void accel_get_start_seq(int , int , int , int , int , int **, int *);

/* accel_release_start_seq frees the array passed to the caller by accel_get_start_seq */
void accel_release_start_seq(int **);
#ifdef __cplusplus
};
#endif
#endif

